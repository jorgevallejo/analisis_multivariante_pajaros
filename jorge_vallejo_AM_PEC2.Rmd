---
title: "Los pájaros de Hunt _(et al.)_"
subtitle: "Análisis Multivariante - PEC 2"
author: "Jorge Vallejo Ortega"
date: '`r format(Sys.Date(),"%e de %B, %Y")`'
output:
  html_document:
     toc: true
# pdf_document:
#   number_sections: true
# toc: true
# extra_dependencies: ["float"]
# urlcolor: blue
# header-includes:
#   - \renewcommand{\contentsname}{Índice}
# - \usepackage{float}

# Next code for knitting both types of documents automatically comes from https://stackoverflow.com/questions/39662365/knit-one-markdown-file-to-two-output-files/53280491#53280491
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding,
                    output_format = NULL,
                    output_dir = "results") })
# And:
# https://stackoverflow.com/a/46007686/10647267

bibliography: references.bib
---
  
```{r setup, include=FALSE}
# knitr options

# Do not display code in output document
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      fig.align = "center")
```

```{r estructura de directorios, results='hide', include=FALSE}
# 'data' contains raw source data.
# 'intermediateData' contains .RData objects with processed data.
# 'results' stores the final report files.

directories <- c("data", "results", "intermediateData", "images")

# Create directories
lapply(directories, function(x){
  if (!(dir.exists(x))){
    dir.create(x)
  }
})
```

```{r delete results files, eval= FALSE, include=FALSE}
# Run this chunk ONLY if you want to re-do
# the complete the report FROM THE ORIGINAL DATA.
# Remember that the .RData files are there to
# avoid unnecesarily redoing of long data processing.

directories <- c("results/", "intermediateData/", "images/")

file.remove(
  # Create a character vector of relative paths
  # to all files in the variable directories
  list.files(path = directories,
             all.files = TRUE,
             full.names = TRUE,
             recursive = TRUE)
)
```

```{r libraries, include=FALSE}
# Load packages
library(knitr)
library(bookdown)
# library(factoextra)
# library(gridExtra)
# library(corrplot)
# library(scatterplot3d)
# library(MVN)
```

# Ejercicio 1. Los pájaros de Hunt (_et al_.)

**En el trabajo de Hunt et al.[-@hunt1986reproductive] se estudió la capacidad reproductiva de cinco especies de aves marinas en dos colonias en el sureste del mar de Bering. Además, el apéndice de este estudio resume las colonias y los tamaños de las poblaciones de otros trabajos. El archivo `seabirds.csv` recoge los datos (número de pájaros) de 23 especies en 9 colonias en el área del norte polar y subpolar. **

**El principal interés de este ejercicio es representar las colonias de diversas formas y estudiar posibles conglomerados.**

En primer lugar, como preparación al ejercicio cargaremos los datos a memoria y examinaremos las características y estructura de los mismos.

```{r load seabirds data}
seabirds <- read.csv("./data/seabirds.csv",
                     stringsAsFactors = FALSE)

kable(
  head(seabirds),
  caption = "Ejemplo de las primeras seis observaciones en la base de datos `seabirds.csv`."
)
```

Si examinamos la estructura de la base de datos:
```{r}
str(seabirds)
```

La base de datos consta de 23 observaciones (files) y 10 variables (columnas). De las diez variables, una corresponde a la especie observada (codificada como cadena de caracteres) y las otras nueve son situaciones geográficas en las que se han obsevado colonias de dichas especies. Los valores que adoptan estas nueve variables son la cantidad de individuos de cada especie, y están codificadas como variables numéricas[^1]:

[^1]: Alternativamente, podríamos reordenar la base de datos para tener sólo tres variables; especie, lugar geográfico y número de individuos. Sin embargo, para los análisis que realizaremos más adelante resulta más cómodo considerar cada lugar geogŕafico como una variable diferente.

Specie: Nombre común de una especie de ave marina.
CH: Número de individuos en la población de Cape Hay.
PLI: Número de individuos en la población de Prince Leopold Island.
CI: Individuos en Caburg Island.
NS: Individuos en North Shields.
CL: Individuos en Cape Lisburne.
CT: Individuos en Cape Thompson.
SI: Individuos en Skomer Island.
SPI: Individuos en St. Paul Island.
SGI: Individuos en George Island.

Finalmente, una forma rápida de buscar valores anómalos y valores ausentes es mediante el resumen numérico:
```{r}
summary(seabirds)
```

No parece haber valores anómalos (entendidos como imposiblemente elevados, negativos, o faltantes) en ninguna de las variables. Sí que podemos ver sin embargo una característica interesante de nuestros datos; la mayoría de valores son ceros. Fijémonos que en el sumario la mayoría de variables presentan valor cero en el segundo, e incluso en el tercer quintil. Esto ya nos adelanta que, en la mayoría de los lugares observados, sólo están presentes menos de la mitad de las especies.


## Ejercicio 1a. Calcular las frecuencias relativas, las frecuencias relativas marginales y la matriz de perfiles. El resultado debería ser la tabla 12.6 del libro de Krebs[-@krebs2014] y que reproducimos al final de este documento.

Anteriormente sólo hemos visto una muestra con las primeras seis filas de la tabla. Aprovecharemos este ejercicio para ver la tabla en su totalidad:
```{r tabla frecuencias}
# Place species as row names
table_N <- seabirds
rownames(table_N) <- seabirds$Specie
table_N <- table_N[, -1]

kable(
  table_N,
  caption = "Tabla de frecuencias de cada especie de ave marina en cada una de las localizaciones."
)
```


### Tabla de frecuencias relativas
```{r tabla frecuencias relativas}
# Create table of relative frecuencies
n <- sum(table_N) # total observed birds
table_F <- table_N/n # relative frequencies

##
# For printing relative f. data without leading zeros
# there is a solution here:
# https://stackoverflow.com/questions/53740145/remove-leading-zeros-in-numbers-within-a-data-frame
# Apply it if there is enough time
# (you will have first to prettyformat the numbers)
##

# Function for dropping leading zeros befor decimal point
# Returns a data.frame of character values
drop.leading.0 <- function(dataf) {
  prettified_t <- format(round(dataf, digits = 6), # round to this decimal
                         zero.print = "0") # What to print when the result is zero
  tableF2 <- data.frame(lapply(prettified_t,
                         function(x) gsub("^0\\.", "\\.", gsub("^-0\\.", "-\\.", as.character(x)))),
                  stringsAsFactors = FALSE, row.names = row.names(prettified_t))
  tableF2
}

# Print relative freq table
kable(
  drop.leading.0(table_F),
  caption = "Tabla de frecuencias relativas de cada especie en cada localización, redondeadas al quinto decimal.",
  align = c(rep('c', 9)) # To center the zeroes (prettier table)
)
```


### Tabla con frecuencias marginales
```{r table frecuencias marginales}
# Design table
table_M <- table_F
table_M$Suma <- apply(table_M, 1, sum) # Add row margin
table_M <- rbind(table_M, # Add columns margin
                      Suma = apply(table_M, 2, sum))

# Print table
kable(
  drop.leading.0(table_M),
  caption = "Tabla de frecuencias relativas más las frecuencias marginales para filas y columnas.",
  align = c(rep('c', 9)) # To center the zeroes (prettier table)
)
```


### Matrices de perfiles
```{r file profiles table}
# Frecuencias relativas condicionadas por filas
table_P <- sweep(table_F, 1, table_M$Suma, "/") 

kable(
  drop.leading.0(table_P),
  caption = "Matriz de perfiles de fila",
  align = c(rep('c', 9)) # To center the zeroes (prettier table)
)
```



```{r column profiles table}
# Frecuencias relativas condicionadas por columnas
table_Pc <- sweep(table_F, 2, t(table_M[nrow(table_M), -ncol(table_M)]), "/") 

kable(
  drop.leading.0(table_F),
  caption = "Matriz de perfiles de columna",
  align = c(rep('c', 9)) # To center the zeroes (prettier table)
)
```



## Ejercicio 1b. Calcular la matriz de distancias ji-cuadrado entre los perfiles de las columnas y su inercia total.


<!-- # Apéndice A: Código -->

<!-- El documento original en formato .Rmd, que incluye el código completo en lenguaje R usado para generar este informe, se puede consultar y descargar en el siguiente repositorio de Github: -->
<!-- [jorgevallejo/RNAseq_analysis_PEC2](https://github.com/jorgevallejo/RNAseq_analysis_PEC2) -->

<!-- # Apéndice B: Reproducibilidad {#apendiceB} -->
<!-- ```{r session_info, include=TRUE, echo=TRUE, results='markup'} -->
<!-- sessionInfo() # For better reproducibility -->
<!-- ``` -->


# Referencias